/*
 * This file has been generated by Oats, please don't modify it by hand!
 * 
 * Generated from https://raw.githubusercontent.com/oats-ts/oats-schemas/master/generated-schemas/bodies.json
 */

import { ExpressToolkit } from '@oats-ts/openapi-express-server-adapter'
import { ClientAdapter, RawHttpRequest, RawHttpResponse, ServerAdapter } from '@oats-ts/openapi-http'
import { Try } from '@oats-ts/try'
import {
  array,
  boolean,
  items,
  lazy,
  literal,
  number,
  object,
  optional,
  shape,
  string,
  tuple,
  union,
} from '@oats-ts/validators'
import { NextFunction, Request, RequestHandler, Response, Router } from 'express'

export type EnumType = 'A' | 'B' | 'C'

export type ObjectWithArrays = {
  boolArr: boolean[]
  enmArr: EnumType[]
  numArr: number[]
  strArr: string[]
}

export type ObjectWithNestedObjects = {
  arrObj: ObjectWithArrays
  primObj: ObjectWithPrimitives
}

export type ObjectWithPrimitives = {
  bool: boolean
  enm: EnumType
  lit: 'Literal Value'
  num: number
  str: string
}

export type PrimitiveOptionalTupleType = ['Literal Value'?, string?, number?, EnumType?, boolean?]

export type PrimitiveTupleType = ['Literal Value', string, number, EnumType, boolean]

export const enumTypeTypeValidator = union({
  A: literal('A'),
  B: literal('B'),
  C: literal('C'),
})

export const objectWithArraysTypeValidator = object(
  shape({
    boolArr: array(items(boolean())),
    enmArr: array(items(lazy(() => enumTypeTypeValidator))),
    numArr: array(items(number())),
    strArr: array(items(string())),
  }),
)

export const objectWithNestedObjectsTypeValidator = object(
  shape({
    arrObj: lazy(() => objectWithArraysTypeValidator),
    primObj: lazy(() => objectWithPrimitivesTypeValidator),
  }),
)

export const objectWithPrimitivesTypeValidator = object(
  shape({
    bool: boolean(),
    enm: lazy(() => enumTypeTypeValidator),
    lit: literal('Literal Value'),
    num: number(),
    str: string(),
  }),
)

export const primitiveOptionalTupleTypeTypeValidator = array(
  tuple(
    optional(literal('Literal Value')),
    optional(string()),
    optional(number()),
    optional(lazy(() => enumTypeTypeValidator)),
    optional(boolean()),
  ),
)

export const primitiveTupleTypeTypeValidator = array(
  tuple(
    literal('Literal Value'),
    string(),
    number(),
    lazy(() => enumTypeTypeValidator),
    boolean(),
  ),
)

export function isEnumType(input: any): input is EnumType {
  return input === 'A' || input === 'B' || input === 'C'
}

export function isObjectWithArrays(input: any): input is ObjectWithArrays {
  return (
    input !== null &&
    typeof input === 'object' &&
    Array.isArray(input.boolArr) &&
    input.boolArr.every((item: any) => typeof item === 'boolean') &&
    Array.isArray(input.enmArr) &&
    input.enmArr.every((item: any) => isEnumType(item)) &&
    Array.isArray(input.numArr) &&
    input.numArr.every((item: any) => typeof item === 'number') &&
    Array.isArray(input.strArr) &&
    input.strArr.every((item: any) => typeof item === 'string')
  )
}

export function isObjectWithNestedObjects(input: any): input is ObjectWithNestedObjects {
  return (
    input !== null &&
    typeof input === 'object' &&
    isObjectWithArrays(input.arrObj) &&
    isObjectWithPrimitives(input.primObj)
  )
}

export function isObjectWithPrimitives(input: any): input is ObjectWithPrimitives {
  return (
    input !== null &&
    typeof input === 'object' &&
    typeof input.bool === 'boolean' &&
    isEnumType(input.enm) &&
    input.lit === 'Literal Value' &&
    typeof input.num === 'number' &&
    typeof input.str === 'string'
  )
}

export function isPrimitiveOptionalTupleType(input: any): input is PrimitiveOptionalTupleType {
  return (
    Array.isArray(input) &&
    (input[0] === null || input[0] === undefined || input[0] === 'Literal Value') &&
    (input[1] === null || input[1] === undefined || typeof input[1] === 'string') &&
    (input[2] === null || input[2] === undefined || typeof input[2] === 'number') &&
    (input[3] === null || input[3] === undefined || isEnumType(input[3])) &&
    (input[4] === null || input[4] === undefined || typeof input[4] === 'boolean')
  )
}

export function isPrimitiveTupleType(input: any): input is PrimitiveTupleType {
  return (
    Array.isArray(input) &&
    input[0] === 'Literal Value' &&
    typeof input[1] === 'string' &&
    typeof input[2] === 'number' &&
    isEnumType(input[3]) &&
    typeof input[4] === 'boolean'
  )
}

export type ArrObjResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: ObjectWithArrays
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: ObjectWithArrays
    }

export type BoolResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: boolean
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: boolean
    }

export type BoolArrResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: boolean[]
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: boolean[]
    }

export type EnmResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: EnumType
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: EnumType
    }

export type EnmArrResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: EnumType[]
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: EnumType[]
    }

export type NestedObjResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: ObjectWithNestedObjects
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: ObjectWithNestedObjects
    }

export type NumResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: number
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: number
    }

export type NumArrResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: number[]
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: number[]
    }

export type OptPrimTupleResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: PrimitiveOptionalTupleType
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: PrimitiveOptionalTupleType
    }

export type PrimObjResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: ObjectWithPrimitives
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: ObjectWithPrimitives
    }

export type PrimTupleResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: PrimitiveTupleType
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: PrimitiveTupleType
    }

export type StrResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: string
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: string
    }

export type StrArrResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: string[]
    }
  | {
      mimeType: 'application/yaml'
      statusCode: 200
      body: string[]
    }

export type ArrObjServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<ObjectWithArrays>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<ObjectWithArrays>
    }

export type BoolServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<boolean>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<boolean>
    }

export type BoolArrServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<boolean[]>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<boolean[]>
    }

export type EnmServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<EnumType>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<EnumType>
    }

export type EnmArrServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<EnumType[]>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<EnumType[]>
    }

export type NestedObjServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<ObjectWithNestedObjects>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<ObjectWithNestedObjects>
    }

export type NumServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<number>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<number>
    }

export type NumArrServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<number[]>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<number[]>
    }

export type OptPrimTupleServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<PrimitiveOptionalTupleType>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<PrimitiveOptionalTupleType>
    }

export type PrimObjServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<ObjectWithPrimitives>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<ObjectWithPrimitives>
    }

export type PrimTupleServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<PrimitiveTupleType>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<PrimitiveTupleType>
    }

export type StrServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<string>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<string>
    }

export type StrArrServerRequest =
  | {
      mimeType: 'application/json'
      body: Try<string[]>
    }
  | {
      mimeType: 'application/yaml'
      body: Try<string[]>
    }

export const arrObjRequestBodyValidator = {
  'application/json': objectWithArraysTypeValidator,
  'application/yaml': objectWithArraysTypeValidator,
} as const

export const boolArrRequestBodyValidator = {
  'application/json': array(items(boolean())),
  'application/yaml': array(items(boolean())),
} as const

export const boolRequestBodyValidator = { 'application/json': boolean(), 'application/yaml': boolean() } as const

export const enmArrRequestBodyValidator = {
  'application/json': array(items(lazy(() => enumTypeTypeValidator))),
  'application/yaml': array(items(lazy(() => enumTypeTypeValidator))),
} as const

export const enmRequestBodyValidator = {
  'application/json': enumTypeTypeValidator,
  'application/yaml': enumTypeTypeValidator,
} as const

export const nestedObjRequestBodyValidator = {
  'application/json': objectWithNestedObjectsTypeValidator,
  'application/yaml': objectWithNestedObjectsTypeValidator,
} as const

export const numArrRequestBodyValidator = {
  'application/json': array(items(number())),
  'application/yaml': array(items(number())),
} as const

export const numRequestBodyValidator = { 'application/json': number(), 'application/yaml': number() } as const

export const optPrimTupleRequestBodyValidator = {
  'application/json': primitiveOptionalTupleTypeTypeValidator,
  'application/yaml': primitiveOptionalTupleTypeTypeValidator,
} as const

export const primObjRequestBodyValidator = {
  'application/json': objectWithPrimitivesTypeValidator,
  'application/yaml': objectWithPrimitivesTypeValidator,
} as const

export const primTupleRequestBodyValidator = {
  'application/json': primitiveTupleTypeTypeValidator,
  'application/yaml': primitiveTupleTypeTypeValidator,
} as const

export const strArrRequestBodyValidator = {
  'application/json': array(items(string())),
  'application/yaml': array(items(string())),
} as const

export const strRequestBodyValidator = { 'application/json': string(), 'application/yaml': string() } as const

export type BodiesApi<T> = {
  arrObj(request: ArrObjServerRequest, toolkit: T): Promise<ArrObjResponse>
  bool(request: BoolServerRequest, toolkit: T): Promise<BoolResponse>
  boolArr(request: BoolArrServerRequest, toolkit: T): Promise<BoolArrResponse>
  enm(request: EnmServerRequest, toolkit: T): Promise<EnmResponse>
  enmArr(request: EnmArrServerRequest, toolkit: T): Promise<EnmArrResponse>
  nestedObj(request: NestedObjServerRequest, toolkit: T): Promise<NestedObjResponse>
  num(request: NumServerRequest, toolkit: T): Promise<NumResponse>
  numArr(request: NumArrServerRequest, toolkit: T): Promise<NumArrResponse>
  optPrimTuple(request: OptPrimTupleServerRequest, toolkit: T): Promise<OptPrimTupleResponse>
  primObj(request: PrimObjServerRequest, toolkit: T): Promise<PrimObjResponse>
  primTuple(request: PrimTupleServerRequest, toolkit: T): Promise<PrimTupleResponse>
  str(request: StrServerRequest, toolkit: T): Promise<StrResponse>
  strArr(request: StrArrServerRequest, toolkit: T): Promise<StrArrResponse>
}

export const arrObjRouter: Router = Router().post(
  '/arr-obj',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', ObjectWithArrays>(
        toolkit,
        mimeType,
        arrObjRequestBodyValidator,
      )
      const typedRequest: ArrObjServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.arrObj(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const boolRouter: Router = Router().post(
  '/bool',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', boolean>(
        toolkit,
        mimeType,
        boolRequestBodyValidator,
      )
      const typedRequest: BoolServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.bool(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const boolArrRouter: Router = Router().post(
  '/bool-arr',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', boolean[]>(
        toolkit,
        mimeType,
        boolArrRequestBodyValidator,
      )
      const typedRequest: BoolArrServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.boolArr(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const enmRouter: Router = Router().post(
  '/enm',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', EnumType>(
        toolkit,
        mimeType,
        enmRequestBodyValidator,
      )
      const typedRequest: EnmServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.enm(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const enmArrRouter: Router = Router().post(
  '/enm-arr',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', EnumType[]>(
        toolkit,
        mimeType,
        enmArrRequestBodyValidator,
      )
      const typedRequest: EnmArrServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.enmArr(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const nestedObjRouter: Router = Router().post(
  '/nested-obj',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', ObjectWithNestedObjects>(
        toolkit,
        mimeType,
        nestedObjRequestBodyValidator,
      )
      const typedRequest: NestedObjServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.nestedObj(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const numRouter: Router = Router().post(
  '/num',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', number>(
        toolkit,
        mimeType,
        numRequestBodyValidator,
      )
      const typedRequest: NumServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.num(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const numArrRouter: Router = Router().post(
  '/num-arr',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', number[]>(
        toolkit,
        mimeType,
        numArrRequestBodyValidator,
      )
      const typedRequest: NumArrServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.numArr(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const optPrimTupleRouter: Router = Router().post(
  '/opt-prim-tuple',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', PrimitiveOptionalTupleType>(
        toolkit,
        mimeType,
        optPrimTupleRequestBodyValidator,
      )
      const typedRequest: OptPrimTupleServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.optPrimTuple(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const primObjRouter: Router = Router().post(
  '/prim-obj',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', ObjectWithPrimitives>(
        toolkit,
        mimeType,
        primObjRequestBodyValidator,
      )
      const typedRequest: PrimObjServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.primObj(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const primTupleRouter: Router = Router().post(
  '/prim-tuple',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', PrimitiveTupleType>(
        toolkit,
        mimeType,
        primTupleRequestBodyValidator,
      )
      const typedRequest: PrimTupleServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.primTuple(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const strRouter: Router = Router().post(
  '/str',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', string>(
        toolkit,
        mimeType,
        strRequestBodyValidator,
      )
      const typedRequest: StrServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.str(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const strArrRouter: Router = Router().post(
  '/str-arr',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BodiesApi<ExpressToolkit> = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json' | 'application/yaml'>(toolkit)
      const body = await adapter.getRequestBody<'application/json' | 'application/yaml', string[]>(
        toolkit,
        mimeType,
        strArrRequestBodyValidator,
      )
      const typedRequest: StrArrServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.strArr(typedRequest, toolkit)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export type BodiesRouters = {
  arrObjRouter: Router
  boolArrRouter: Router
  boolRouter: Router
  enmArrRouter: Router
  enmRouter: Router
  nestedObjRouter: Router
  numArrRouter: Router
  numRouter: Router
  optPrimTupleRouter: Router
  primObjRouter: Router
  primTupleRouter: Router
  strArrRouter: Router
  strRouter: Router
}

export function createBodiesRouter(
  api: BodiesApi<ExpressToolkit>,
  adapter: ServerAdapter<ExpressToolkit>,
  routes: Partial<BodiesRouters> = {},
): Router {
  return Router().use(
    (_, response, next) => {
      response.locals['__oats_api'] = api
      response.locals['__oats_adapter'] = adapter
      next()
    },
    routes.arrObjRouter ?? arrObjRouter,
    routes.boolArrRouter ?? boolArrRouter,
    routes.boolRouter ?? boolRouter,
    routes.enmArrRouter ?? enmArrRouter,
    routes.enmRouter ?? enmRouter,
    routes.nestedObjRouter ?? nestedObjRouter,
    routes.numArrRouter ?? numArrRouter,
    routes.numRouter ?? numRouter,
    routes.optPrimTupleRouter ?? optPrimTupleRouter,
    routes.primObjRouter ?? primObjRouter,
    routes.primTupleRouter ?? primTupleRouter,
    routes.strArrRouter ?? strArrRouter,
    routes.strRouter ?? strRouter,
  )
}

export const bodiesCorsMiddleware =
  (isAccepted: (request: Request) => boolean): RequestHandler =>
  (request: Request, response: Response, next: NextFunction) => {
    if (isAccepted(request)) {
      response.setHeader('Access-Control-Allow-Origin', request.headers.origin ?? '*')
      response.setHeader('Access-Control-Allow-Methods', 'POST')
      response.setHeader('Access-Control-Allow-Headers', 'content-type')
    }
    next()
  }

export type ArrObjRequest =
  | {
      mimeType: 'application/json'
      body: ObjectWithArrays
    }
  | {
      mimeType: 'application/yaml'
      body: ObjectWithArrays
    }

export type BoolRequest =
  | {
      mimeType: 'application/json'
      body: boolean
    }
  | {
      mimeType: 'application/yaml'
      body: boolean
    }

export type BoolArrRequest =
  | {
      mimeType: 'application/json'
      body: boolean[]
    }
  | {
      mimeType: 'application/yaml'
      body: boolean[]
    }

export type EnmRequest =
  | {
      mimeType: 'application/json'
      body: EnumType
    }
  | {
      mimeType: 'application/yaml'
      body: EnumType
    }

export type EnmArrRequest =
  | {
      mimeType: 'application/json'
      body: EnumType[]
    }
  | {
      mimeType: 'application/yaml'
      body: EnumType[]
    }

export type NestedObjRequest =
  | {
      mimeType: 'application/json'
      body: ObjectWithNestedObjects
    }
  | {
      mimeType: 'application/yaml'
      body: ObjectWithNestedObjects
    }

export type NumRequest =
  | {
      mimeType: 'application/json'
      body: number
    }
  | {
      mimeType: 'application/yaml'
      body: number
    }

export type NumArrRequest =
  | {
      mimeType: 'application/json'
      body: number[]
    }
  | {
      mimeType: 'application/yaml'
      body: number[]
    }

export type OptPrimTupleRequest =
  | {
      mimeType: 'application/json'
      body: PrimitiveOptionalTupleType
    }
  | {
      mimeType: 'application/yaml'
      body: PrimitiveOptionalTupleType
    }

export type PrimObjRequest =
  | {
      mimeType: 'application/json'
      body: ObjectWithPrimitives
    }
  | {
      mimeType: 'application/yaml'
      body: ObjectWithPrimitives
    }

export type PrimTupleRequest =
  | {
      mimeType: 'application/json'
      body: PrimitiveTupleType
    }
  | {
      mimeType: 'application/yaml'
      body: PrimitiveTupleType
    }

export type StrRequest =
  | {
      mimeType: 'application/json'
      body: string
    }
  | {
      mimeType: 'application/yaml'
      body: string
    }

export type StrArrRequest =
  | {
      mimeType: 'application/json'
      body: string[]
    }
  | {
      mimeType: 'application/yaml'
      body: string[]
    }

export const arrObjResponseBodyValidator = {
  200: { 'application/json': objectWithArraysTypeValidator, 'application/yaml': objectWithArraysTypeValidator },
} as const

export const boolArrResponseBodyValidator = {
  200: { 'application/json': array(items(boolean())), 'application/yaml': array(items(boolean())) },
} as const

export const boolResponseBodyValidator = {
  200: { 'application/json': boolean(), 'application/yaml': boolean() },
} as const

export const enmArrResponseBodyValidator = {
  200: {
    'application/json': array(items(lazy(() => enumTypeTypeValidator))),
    'application/yaml': array(items(lazy(() => enumTypeTypeValidator))),
  },
} as const

export const enmResponseBodyValidator = {
  200: { 'application/json': enumTypeTypeValidator, 'application/yaml': enumTypeTypeValidator },
} as const

export const nestedObjResponseBodyValidator = {
  200: {
    'application/json': objectWithNestedObjectsTypeValidator,
    'application/yaml': objectWithNestedObjectsTypeValidator,
  },
} as const

export const numArrResponseBodyValidator = {
  200: { 'application/json': array(items(number())), 'application/yaml': array(items(number())) },
} as const

export const numResponseBodyValidator = { 200: { 'application/json': number(), 'application/yaml': number() } } as const

export const optPrimTupleResponseBodyValidator = {
  200: {
    'application/json': primitiveOptionalTupleTypeTypeValidator,
    'application/yaml': primitiveOptionalTupleTypeTypeValidator,
  },
} as const

export const primObjResponseBodyValidator = {
  200: { 'application/json': objectWithPrimitivesTypeValidator, 'application/yaml': objectWithPrimitivesTypeValidator },
} as const

export const primTupleResponseBodyValidator = {
  200: { 'application/json': primitiveTupleTypeTypeValidator, 'application/yaml': primitiveTupleTypeTypeValidator },
} as const

export const strArrResponseBodyValidator = {
  200: { 'application/json': array(items(string())), 'application/yaml': array(items(string())) },
} as const

export const strResponseBodyValidator = { 200: { 'application/json': string(), 'application/yaml': string() } } as const

export async function arrObj(input: ArrObjRequest, adapter: ClientAdapter): Promise<ArrObjResponse> {
  const requestUrl = await adapter.getUrl('/arr-obj', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, arrObjResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as ArrObjResponse
  return response
}

export async function bool(input: BoolRequest, adapter: ClientAdapter): Promise<BoolResponse> {
  const requestUrl = await adapter.getUrl('/bool', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, boolResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as BoolResponse
  return response
}

export async function boolArr(input: BoolArrRequest, adapter: ClientAdapter): Promise<BoolArrResponse> {
  const requestUrl = await adapter.getUrl('/bool-arr', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, boolArrResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as BoolArrResponse
  return response
}

export async function enm(input: EnmRequest, adapter: ClientAdapter): Promise<EnmResponse> {
  const requestUrl = await adapter.getUrl('/enm', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, enmResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as EnmResponse
  return response
}

export async function enmArr(input: EnmArrRequest, adapter: ClientAdapter): Promise<EnmArrResponse> {
  const requestUrl = await adapter.getUrl('/enm-arr', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, enmArrResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as EnmArrResponse
  return response
}

export async function nestedObj(input: NestedObjRequest, adapter: ClientAdapter): Promise<NestedObjResponse> {
  const requestUrl = await adapter.getUrl('/nested-obj', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, nestedObjResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as NestedObjResponse
  return response
}

export async function num(input: NumRequest, adapter: ClientAdapter): Promise<NumResponse> {
  const requestUrl = await adapter.getUrl('/num', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, numResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as NumResponse
  return response
}

export async function numArr(input: NumArrRequest, adapter: ClientAdapter): Promise<NumArrResponse> {
  const requestUrl = await adapter.getUrl('/num-arr', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, numArrResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as NumArrResponse
  return response
}

export async function optPrimTuple(input: OptPrimTupleRequest, adapter: ClientAdapter): Promise<OptPrimTupleResponse> {
  const requestUrl = await adapter.getUrl('/opt-prim-tuple', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(
    rawResponse,
    statusCode,
    mimeType,
    optPrimTupleResponseBodyValidator,
  )
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as OptPrimTupleResponse
  return response
}

export async function primObj(input: PrimObjRequest, adapter: ClientAdapter): Promise<PrimObjResponse> {
  const requestUrl = await adapter.getUrl('/prim-obj', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, primObjResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as PrimObjResponse
  return response
}

export async function primTuple(input: PrimTupleRequest, adapter: ClientAdapter): Promise<PrimTupleResponse> {
  const requestUrl = await adapter.getUrl('/prim-tuple', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, primTupleResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as PrimTupleResponse
  return response
}

export async function str(input: StrRequest, adapter: ClientAdapter): Promise<StrResponse> {
  const requestUrl = await adapter.getUrl('/str', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, strResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as StrResponse
  return response
}

export async function strArr(input: StrArrRequest, adapter: ClientAdapter): Promise<StrArrResponse> {
  const requestUrl = await adapter.getUrl('/str-arr', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, strArrResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as StrArrResponse
  return response
}

export type BodiesSdk = {
  arrObj(input: ArrObjRequest): Promise<ArrObjResponse>
  bool(input: BoolRequest): Promise<BoolResponse>
  boolArr(input: BoolArrRequest): Promise<BoolArrResponse>
  enm(input: EnmRequest): Promise<EnmResponse>
  enmArr(input: EnmArrRequest): Promise<EnmArrResponse>
  nestedObj(input: NestedObjRequest): Promise<NestedObjResponse>
  num(input: NumRequest): Promise<NumResponse>
  numArr(input: NumArrRequest): Promise<NumArrResponse>
  optPrimTuple(input: OptPrimTupleRequest): Promise<OptPrimTupleResponse>
  primObj(input: PrimObjRequest): Promise<PrimObjResponse>
  primTuple(input: PrimTupleRequest): Promise<PrimTupleResponse>
  str(input: StrRequest): Promise<StrResponse>
  strArr(input: StrArrRequest): Promise<StrArrResponse>
}

export class BodiesSdkImpl implements BodiesSdk {
  protected readonly adapter: ClientAdapter
  public constructor(adapter: ClientAdapter) {
    this.adapter = adapter
  }
  public async arrObj(input: ArrObjRequest): Promise<ArrObjResponse> {
    return arrObj(input, this.adapter)
  }
  public async bool(input: BoolRequest): Promise<BoolResponse> {
    return bool(input, this.adapter)
  }
  public async boolArr(input: BoolArrRequest): Promise<BoolArrResponse> {
    return boolArr(input, this.adapter)
  }
  public async enm(input: EnmRequest): Promise<EnmResponse> {
    return enm(input, this.adapter)
  }
  public async enmArr(input: EnmArrRequest): Promise<EnmArrResponse> {
    return enmArr(input, this.adapter)
  }
  public async nestedObj(input: NestedObjRequest): Promise<NestedObjResponse> {
    return nestedObj(input, this.adapter)
  }
  public async num(input: NumRequest): Promise<NumResponse> {
    return num(input, this.adapter)
  }
  public async numArr(input: NumArrRequest): Promise<NumArrResponse> {
    return numArr(input, this.adapter)
  }
  public async optPrimTuple(input: OptPrimTupleRequest): Promise<OptPrimTupleResponse> {
    return optPrimTuple(input, this.adapter)
  }
  public async primObj(input: PrimObjRequest): Promise<PrimObjResponse> {
    return primObj(input, this.adapter)
  }
  public async primTuple(input: PrimTupleRequest): Promise<PrimTupleResponse> {
    return primTuple(input, this.adapter)
  }
  public async str(input: StrRequest): Promise<StrResponse> {
    return str(input, this.adapter)
  }
  public async strArr(input: StrArrRequest): Promise<StrArrResponse> {
    return strArr(input, this.adapter)
  }
}

export class BodiesSdkStub implements BodiesSdk {
  public async arrObj(_input: ArrObjRequest): Promise<ArrObjResponse> {
    throw new Error('Stub method "arrObj" called. You should implement this method if you want to use it.')
  }
  public async bool(_input: BoolRequest): Promise<BoolResponse> {
    throw new Error('Stub method "bool" called. You should implement this method if you want to use it.')
  }
  public async boolArr(_input: BoolArrRequest): Promise<BoolArrResponse> {
    throw new Error('Stub method "boolArr" called. You should implement this method if you want to use it.')
  }
  public async enm(_input: EnmRequest): Promise<EnmResponse> {
    throw new Error('Stub method "enm" called. You should implement this method if you want to use it.')
  }
  public async enmArr(_input: EnmArrRequest): Promise<EnmArrResponse> {
    throw new Error('Stub method "enmArr" called. You should implement this method if you want to use it.')
  }
  public async nestedObj(_input: NestedObjRequest): Promise<NestedObjResponse> {
    throw new Error('Stub method "nestedObj" called. You should implement this method if you want to use it.')
  }
  public async num(_input: NumRequest): Promise<NumResponse> {
    throw new Error('Stub method "num" called. You should implement this method if you want to use it.')
  }
  public async numArr(_input: NumArrRequest): Promise<NumArrResponse> {
    throw new Error('Stub method "numArr" called. You should implement this method if you want to use it.')
  }
  public async optPrimTuple(_input: OptPrimTupleRequest): Promise<OptPrimTupleResponse> {
    throw new Error('Stub method "optPrimTuple" called. You should implement this method if you want to use it.')
  }
  public async primObj(_input: PrimObjRequest): Promise<PrimObjResponse> {
    throw new Error('Stub method "primObj" called. You should implement this method if you want to use it.')
  }
  public async primTuple(_input: PrimTupleRequest): Promise<PrimTupleResponse> {
    throw new Error('Stub method "primTuple" called. You should implement this method if you want to use it.')
  }
  public async str(_input: StrRequest): Promise<StrResponse> {
    throw new Error('Stub method "str" called. You should implement this method if you want to use it.')
  }
  public async strArr(_input: StrArrRequest): Promise<StrArrResponse> {
    throw new Error('Stub method "strArr" called. You should implement this method if you want to use it.')
  }
}
