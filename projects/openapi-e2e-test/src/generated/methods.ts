/*
 * This file has been generated by Oats, please don't modify it by hand!
 *
 * Generated from https://raw.githubusercontent.com/oats-ts/oats-schemas/master/generated-schemas/methods.json
 */

import { ExpressToolkit } from '@oats-ts/openapi-express-server-adapter'
import { ClientAdapter, RawHttpRequest, RawHttpResponse, ServerAdapter } from '@oats-ts/openapi-http'
import { object, shape, string } from '@oats-ts/validators'
import { NextFunction, Request, RequestHandler, Response, Router } from 'express'

export type DeleteMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type GetMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type OptionsMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type PatchMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type PostMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type PutMethodResponse = {
  mimeType: 'application/json'
  statusCode: 200
  body: {
    methodUsed: string
  }
}

export type HttpMethodsApi = {
  getMethod(): Promise<GetMethodResponse>
  postMethod(): Promise<PostMethodResponse>
  putMethod(): Promise<PutMethodResponse>
  patchMethod(): Promise<PatchMethodResponse>
  optionsMethod(): Promise<OptionsMethodResponse>
  deleteMethod(): Promise<DeleteMethodResponse>
}

export const deleteMethodRouter: Router = Router().delete(
  '/delete-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.deleteMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const getMethodRouter: Router = Router().get(
  '/get-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.getMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const optionsMethodRouter: Router = Router().options(
  '/options-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.optionsMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const patchMethodRouter: Router = Router().patch(
  '/patch-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.patchMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const postMethodRouter: Router = Router().post(
  '/post-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.postMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const putMethodRouter: Router = Router().put(
  '/put-method',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: HttpMethodsApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.putMethod()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export type HttpMethodsRouters = {
  getMethodRouter: Router
  postMethodRouter: Router
  putMethodRouter: Router
  patchMethodRouter: Router
  optionsMethodRouter: Router
  deleteMethodRouter: Router
}

export function createHttpMethodsRouter(
  api: HttpMethodsApi,
  adapter: ServerAdapter<ExpressToolkit>,
  routes: Partial<HttpMethodsRouters> = {},
): Router {
  return Router().use(
    (_, response, next) => {
      response.locals['__oats_api'] = api
      response.locals['__oats_adapter'] = adapter
      next()
    },
    routes.getMethodRouter ?? getMethodRouter,
    routes.postMethodRouter ?? postMethodRouter,
    routes.putMethodRouter ?? putMethodRouter,
    routes.patchMethodRouter ?? patchMethodRouter,
    routes.optionsMethodRouter ?? optionsMethodRouter,
    routes.deleteMethodRouter ?? deleteMethodRouter,
  )
}

export const httpMethodsCorsMiddleware =
  (isAccepted: (request: Request) => boolean): RequestHandler =>
  (request: Request, response: Response, next: NextFunction) => {
    if (isAccepted(request)) {
      response.setHeader('Access-Control-Allow-Origin', request.headers.origin ?? '*')
      response.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, OPTIONS, DELETE')
      response.setHeader('Access-Control-Expose-Headers', 'content-type')
    }
    next()
  }

export const deleteMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export const getMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export const optionsMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export const patchMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export const postMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export const putMethodResponseBodyValidator = {
  200: { 'application/json': object(shape({ methodUsed: string() })) },
} as const

export async function deleteMethod(adapter: ClientAdapter): Promise<DeleteMethodResponse> {
  const requestUrl = await adapter.getUrl('/delete-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'delete',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(
    rawResponse,
    statusCode,
    mimeType,
    deleteMethodResponseBodyValidator,
  )
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as DeleteMethodResponse
}

export async function getMethod(adapter: ClientAdapter): Promise<GetMethodResponse> {
  const requestUrl = await adapter.getUrl('/get-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'get',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, getMethodResponseBodyValidator)
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as GetMethodResponse
}

export async function optionsMethod(adapter: ClientAdapter): Promise<OptionsMethodResponse> {
  const requestUrl = await adapter.getUrl('/options-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'options',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(
    rawResponse,
    statusCode,
    mimeType,
    optionsMethodResponseBodyValidator,
  )
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as OptionsMethodResponse
}

export async function patchMethod(adapter: ClientAdapter): Promise<PatchMethodResponse> {
  const requestUrl = await adapter.getUrl('/patch-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'patch',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(
    rawResponse,
    statusCode,
    mimeType,
    patchMethodResponseBodyValidator,
  )
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as PatchMethodResponse
}

export async function postMethod(adapter: ClientAdapter): Promise<PostMethodResponse> {
  const requestUrl = await adapter.getUrl('/post-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, postMethodResponseBodyValidator)
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as PostMethodResponse
}

export async function putMethod(adapter: ClientAdapter): Promise<PutMethodResponse> {
  const requestUrl = await adapter.getUrl('/put-method', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'put',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, putMethodResponseBodyValidator)
  return {
    mimeType,
    statusCode,
    body: responseBody,
  } as PutMethodResponse
}

export type HttpMethodsSdk = {
  getMethod(): Promise<GetMethodResponse>
  postMethod(): Promise<PostMethodResponse>
  putMethod(): Promise<PutMethodResponse>
  patchMethod(): Promise<PatchMethodResponse>
  optionsMethod(): Promise<OptionsMethodResponse>
  deleteMethod(): Promise<DeleteMethodResponse>
}

export class HttpMethodsSdkImpl implements HttpMethodsSdk {
  protected readonly adapter: ClientAdapter
  public constructor(adapter: ClientAdapter) {
    this.adapter = adapter
  }
  public async getMethod(): Promise<GetMethodResponse> {
    return getMethod(this.adapter)
  }
  public async postMethod(): Promise<PostMethodResponse> {
    return postMethod(this.adapter)
  }
  public async putMethod(): Promise<PutMethodResponse> {
    return putMethod(this.adapter)
  }
  public async patchMethod(): Promise<PatchMethodResponse> {
    return patchMethod(this.adapter)
  }
  public async optionsMethod(): Promise<OptionsMethodResponse> {
    return optionsMethod(this.adapter)
  }
  public async deleteMethod(): Promise<DeleteMethodResponse> {
    return deleteMethod(this.adapter)
  }
}
