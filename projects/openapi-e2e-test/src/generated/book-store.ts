/*
 * This file has been generated by Oats, please don't modify it by hand!
 * 
 * Generated from https://raw.githubusercontent.com/oats-ts/oats-schemas/master/schemas/book-store.json
 */

import { ExpressToolkit } from '@oats-ts/openapi-express-server-adapter'
import { ClientAdapter, RawHttpRequest, RawHttpResponse, ServerAdapter } from '@oats-ts/openapi-http'
import { createPathDeserializer, deserializers } from '@oats-ts/openapi-parameter-deserialization'
import { createPathSerializer, serializers } from '@oats-ts/openapi-parameter-serialization'
import { Try } from '@oats-ts/try'
import { array, items, lazy, literal, number, object, optional, shape, string, union } from '@oats-ts/validators'
import { NextFunction, Request, RequestHandler, Response, Router } from 'express'

export type AppError = {
  message: string
}

export type Book = {
  author: string
  bookType: BookType
  description?: string
  id: number
  price: number
  title: string
}

export type BookType = 'paperback' | 'digital' | 'audio'

export const appErrorTypeValidator = object(shape({ message: string() }))

export const bookTypeTypeValidator = union({
  paperback: literal('paperback'),
  digital: literal('digital'),
  audio: literal('audio'),
})

export const bookTypeValidator = object(
  shape({
    author: string(),
    bookType: lazy(() => bookTypeTypeValidator),
    description: optional(string()),
    id: number(),
    price: number(),
    title: string(),
  }),
)

export function isAppError(input: any): input is AppError {
  return input !== null && typeof input === 'object' && typeof input.message === 'string'
}

export function isBook(input: any): input is Book {
  return (
    input !== null &&
    typeof input === 'object' &&
    typeof input.author === 'string' &&
    isBookType(input.bookType) &&
    (input.description === null || input.description === undefined || typeof input.description === 'string') &&
    typeof input.id === 'number' &&
    typeof input.price === 'number' &&
    typeof input.title === 'string'
  )
}

export function isBookType(input: any): input is BookType {
  return input === 'paperback' || input === 'digital' || input === 'audio'
}

export type GetBookPathParameters = {
  /**
   * The id of the book
   */
  bookId: number
}

export type UpdateBookPathParameters = {
  /**
   * The id of the book
   */
  bookId: number
}

export type CreateBookResponse =
  | {
      mimeType: 'application/json'
      statusCode: 201
      body: Book
    }
  | {
      mimeType: 'application/json'
      statusCode: 400
      body: AppError[]
    }
  | {
      mimeType: 'application/json'
      statusCode: 500
      body: AppError[]
    }

export type GetBookResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: Book
    }
  | {
      mimeType: 'application/json'
      statusCode: 400
      body: AppError[]
    }
  | {
      mimeType: 'application/json'
      statusCode: 500
      body: AppError[]
    }

export type GetBooksResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: Book[]
    }
  | {
      mimeType: 'application/json'
      statusCode: 400
      body: AppError[]
    }
  | {
      mimeType: 'application/json'
      statusCode: 500
      body: AppError[]
    }

export type UpdateBookResponse =
  | {
      mimeType: 'application/json'
      statusCode: 200
      body: Book
    }
  | {
      mimeType: 'application/json'
      statusCode: 400
      body: AppError[]
    }
  | {
      mimeType: 'application/json'
      statusCode: 500
      body: AppError[]
    }

export type CreateBookServerRequest = {
  mimeType: 'application/json'
  body: Try<Book>
}

export type GetBookServerRequest = {
  path: Try<GetBookPathParameters>
}

export type UpdateBookServerRequest = {
  path: Try<UpdateBookPathParameters>
  mimeType: 'application/json'
  body: Try<Book>
}

export const createBookRequestBodyValidator = { 'application/json': bookTypeValidator } as const

export const updateBookRequestBodyValidator = { 'application/json': bookTypeValidator } as const

export const getBookPathDeserializer = createPathDeserializer<GetBookPathParameters>(
  ['bookId'],
  /^\/books(?:\/([^\/#\?]+?))[\/#\?]?$/i,
  { bookId: deserializers.path.simple.primitive(deserializers.value.number(), {}) },
)

export const updateBookPathDeserializer = createPathDeserializer<UpdateBookPathParameters>(
  ['bookId'],
  /^\/books(?:\/([^\/#\?]+?))[\/#\?]?$/i,
  { bookId: deserializers.path.simple.primitive(deserializers.value.number(), {}) },
)

export type BookStoreApi = {
  /**
   * Creates a new book based on the request body. The id field can be ommited (will be ignored)
   */
  createBook(request: CreateBookServerRequest): Promise<CreateBookResponse>
  /**
   * Returns the book associated with the given bookId
   */
  getBook(request: GetBookServerRequest): Promise<GetBookResponse>
  getBooks(): Promise<GetBooksResponse>
  /**
   * Updates the book associated with the given bookId
   */
  updateBook(request: UpdateBookServerRequest): Promise<UpdateBookResponse>
}

export const createBookRouter: Router = Router().post(
  '/books',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BookStoreApi = response.locals['__oats_api']
    try {
      const mimeType = await adapter.getMimeType<'application/json'>(toolkit)
      const body = await adapter.getRequestBody<'application/json', Book>(
        toolkit,
        mimeType,
        createBookRequestBodyValidator,
      )
      const typedRequest: CreateBookServerRequest = {
        mimeType,
        body,
      }
      const typedResponse = await api.createBook(typedRequest)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const getBookRouter: Router = Router().get(
  '/books/:bookId',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BookStoreApi = response.locals['__oats_api']
    try {
      const path = await adapter.getPathParameters(toolkit, getBookPathDeserializer)
      const typedRequest: GetBookServerRequest = {
        path,
      }
      const typedResponse = await api.getBook(typedRequest)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const getBooksRouter: Router = Router().get(
  '/books',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BookStoreApi = response.locals['__oats_api']
    try {
      const typedResponse = await api.getBooks()
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export const updateBookRouter: Router = Router().patch(
  '/books/:bookId',
  async (request: Request, response: Response, next: NextFunction): Promise<void> => {
    const toolkit: ExpressToolkit = { request, response, next }
    const adapter: ServerAdapter<ExpressToolkit> = response.locals['__oats_adapter']
    const api: BookStoreApi = response.locals['__oats_api']
    try {
      const path = await adapter.getPathParameters(toolkit, updateBookPathDeserializer)
      const mimeType = await adapter.getMimeType<'application/json'>(toolkit)
      const body = await adapter.getRequestBody<'application/json', Book>(
        toolkit,
        mimeType,
        updateBookRequestBodyValidator,
      )
      const typedRequest: UpdateBookServerRequest = {
        path,
        mimeType,
        body,
      }
      const typedResponse = await api.updateBook(typedRequest)
      const rawResponse: RawHttpResponse = {
        headers: await adapter.getResponseHeaders(toolkit, typedResponse, undefined),
        statusCode: await adapter.getStatusCode(toolkit, typedResponse),
        body: await adapter.getResponseBody(toolkit, typedResponse),
      }
      return adapter.respond(toolkit, rawResponse)
    } catch (error) {
      adapter.handleError(toolkit, error)
    }
  },
)

export type BookStoreRouters = {
  createBookRouter: Router
  getBookRouter: Router
  getBooksRouter: Router
  updateBookRouter: Router
}

export function createBookStoreRouter(
  api: BookStoreApi,
  adapter: ServerAdapter<ExpressToolkit>,
  routes: Partial<BookStoreRouters> = {},
): Router {
  return Router().use(
    (_, response, next) => {
      response.locals['__oats_api'] = api
      response.locals['__oats_adapter'] = adapter
      next()
    },
    routes.createBookRouter ?? createBookRouter,
    routes.getBookRouter ?? getBookRouter,
    routes.getBooksRouter ?? getBooksRouter,
    routes.updateBookRouter ?? updateBookRouter,
  )
}

export const bookStoreCorsMiddleware =
  (isAccepted: (request: Request) => boolean): RequestHandler =>
  (request: Request, response: Response, next: NextFunction) => {
    if (isAccepted(request)) {
      response.setHeader('Access-Control-Allow-Origin', request.headers.origin ?? '*')
      response.setHeader('Access-Control-Allow-Methods', 'POST, GET, PATCH')
      response.setHeader('Access-Control-Allow-Headers', 'content-type')
    }
    next()
  }

export type CreateBookRequest = {
  mimeType: 'application/json'
  body: Book
}

export type GetBookRequest = {
  path: GetBookPathParameters
}

export type UpdateBookRequest = {
  path: UpdateBookPathParameters
  mimeType: 'application/json'
  body: Book
}

export const createBookResponseBodyValidator = {
  201: { 'application/json': bookTypeValidator },
  400: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
  500: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
} as const

export const getBookResponseBodyValidator = {
  200: { 'application/json': bookTypeValidator },
  400: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
  500: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
} as const

export const getBooksResponseBodyValidator = {
  200: { 'application/json': array(items(lazy(() => bookTypeValidator))) },
  400: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
  500: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
} as const

export const updateBookResponseBodyValidator = {
  200: { 'application/json': bookTypeValidator },
  400: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
  500: { 'application/json': array(items(lazy(() => appErrorTypeValidator))) },
} as const

export const getBookPathSerializer = createPathSerializer<GetBookPathParameters>('/books/{bookId}', {
  bookId: serializers.path.simple.primitive<number>({}),
})

export const updateBookPathSerializer = createPathSerializer<UpdateBookPathParameters>('/books/{bookId}', {
  bookId: serializers.path.simple.primitive<number>({}),
})

/**
 * Creates a new book based on the request body. The id field can be ommited (will be ignored)
 */
export async function createBook(input: CreateBookRequest, adapter: ClientAdapter): Promise<CreateBookResponse> {
  const requestUrl = await adapter.getUrl('/books', undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'post',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, createBookResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as CreateBookResponse
  return response
}

/**
 * Returns the book associated with the given bookId
 */
export async function getBook(input: GetBookRequest, adapter: ClientAdapter): Promise<GetBookResponse> {
  const path = await adapter.getPath(input, getBookPathSerializer)
  const requestUrl = await adapter.getUrl(path, undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'get',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, getBookResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as GetBookResponse
  return response
}

export async function getBooks(adapter: ClientAdapter): Promise<GetBooksResponse> {
  const requestUrl = await adapter.getUrl('/books', undefined)
  const requestHeaders = await adapter.getRequestHeaders(undefined, undefined)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'get',
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, getBooksResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as GetBooksResponse
  return response
}

/**
 * Updates the book associated with the given bookId
 */
export async function updateBook(input: UpdateBookRequest, adapter: ClientAdapter): Promise<UpdateBookResponse> {
  const path = await adapter.getPath(input, updateBookPathSerializer)
  const requestUrl = await adapter.getUrl(path, undefined)
  const requestHeaders = await adapter.getRequestHeaders(input, undefined)
  const requestBody = await adapter.getRequestBody(input)
  const rawRequest: RawHttpRequest = {
    url: requestUrl,
    method: 'patch',
    body: requestBody,
    headers: requestHeaders,
  }
  const rawResponse = await adapter.request(rawRequest)
  const mimeType = await adapter.getMimeType(rawResponse)
  const statusCode = await adapter.getStatusCode(rawResponse)
  const responseHeaders = await adapter.getResponseHeaders(rawResponse, statusCode, undefined)
  const responseBody = await adapter.getResponseBody(rawResponse, statusCode, mimeType, updateBookResponseBodyValidator)
  const response = {
    mimeType,
    statusCode,
    headers: responseHeaders,
    body: responseBody,
  } as UpdateBookResponse
  return response
}

export type BookStoreSdk = {
  /**
   * Creates a new book based on the request body. The id field can be ommited (will be ignored)
   */
  createBook(input: CreateBookRequest): Promise<CreateBookResponse>
  /**
   * Returns the book associated with the given bookId
   */
  getBook(input: GetBookRequest): Promise<GetBookResponse>
  getBooks(): Promise<GetBooksResponse>
  /**
   * Updates the book associated with the given bookId
   */
  updateBook(input: UpdateBookRequest): Promise<UpdateBookResponse>
}

export class BookStoreSdkImpl implements BookStoreSdk {
  protected readonly adapter: ClientAdapter
  public constructor(adapter: ClientAdapter) {
    this.adapter = adapter
  }
  public async createBook(input: CreateBookRequest): Promise<CreateBookResponse> {
    return createBook(input, this.adapter)
  }
  public async getBook(input: GetBookRequest): Promise<GetBookResponse> {
    return getBook(input, this.adapter)
  }
  public async getBooks(): Promise<GetBooksResponse> {
    return getBooks(this.adapter)
  }
  public async updateBook(input: UpdateBookRequest): Promise<UpdateBookResponse> {
    return updateBook(input, this.adapter)
  }
}

export class BookStoreSdkStub implements BookStoreSdk {
  public async createBook(_input: CreateBookRequest): Promise<CreateBookResponse> {
    throw new Error('Stub method "createBook" called. You should implement this method if you want to use it.')
  }
  public async getBook(_input: GetBookRequest): Promise<GetBookResponse> {
    throw new Error('Stub method "getBook" called. You should implement this method if you want to use it.')
  }
  public async getBooks(): Promise<GetBooksResponse> {
    throw new Error('Stub method "getBooks" called. You should implement this method if you want to use it.')
  }
  public async updateBook(_input: UpdateBookRequest): Promise<UpdateBookResponse> {
    throw new Error('Stub method "updateBook" called. You should implement this method if you want to use it.')
  }
}
